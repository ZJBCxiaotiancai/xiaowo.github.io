{"meta":{"title":"小蜗的博客","subtitle":"my blog","description":"this is my blog","author":"Elijah","url":"https://zjbcxiaotiancai.github.io/xiaowo.github.io","root":"/"},"pages":[{"title":"about","date":"2023-04-21T03:04:24.000Z","updated":"2023-04-21T03:04:24.257Z","comments":true,"path":"about/index.html","permalink":"https://zjbcxiaotiancai.github.io/xiaowo.github.io/about/index.html","excerpt":"","text":""},{"title":"archives","date":"2023-04-21T03:09:30.000Z","updated":"2023-04-21T03:09:30.600Z","comments":true,"path":"archives/index.html","permalink":"https://zjbcxiaotiancai.github.io/xiaowo.github.io/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2023-04-21T03:05:18.000Z","updated":"2023-04-21T03:05:18.068Z","comments":true,"path":"categories/index.html","permalink":"https://zjbcxiaotiancai.github.io/xiaowo.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-04-21T03:04:58.000Z","updated":"2023-04-21T03:04:58.100Z","comments":true,"path":"tags/index.html","permalink":"https://zjbcxiaotiancai.github.io/xiaowo.github.io/tags/index.html","excerpt":"","text":""},{"title":"friends","date":"2023-04-21T03:04:49.000Z","updated":"2023-04-21T03:04:49.694Z","comments":true,"path":"friends/index.html","permalink":"https://zjbcxiaotiancai.github.io/xiaowo.github.io/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"Redis","slug":"Redis","date":"2023-05-18T02:44:25.000Z","updated":"2023-05-21T13:40:26.537Z","comments":true,"path":"2023/05/18/Redis/","link":"","permalink":"https://zjbcxiaotiancai.github.io/xiaowo.github.io/2023/05/18/Redis/","excerpt":"","text":"Nosql为什么要用nosql？ NoSQL概念随着web2.0的快速发展，非关系型、分布式数据存储得到了快速的发展，它们不保证关系数据的ACID特性。NoSQL概念在2009年被提了出来。NoSQL最常见的解释是“non-relational”，“Not Only SQL”也被很多人接受。（“NoSQL”一词最早于1998年被用于一个轻量级的关系数据库的名字。） NoSQL被我们用得最多的当数key-value存储，当然还有其他的文档型的、列存储、图型数据库、xml数据库等。在NoSQL概念提出之前，这些数据库就被用于各种系统当中，但是却很少用于web互联网应用。比如cdb、qdbm、bdb数据库。 什么是nosqlNoSQL(Not only SQL)是对不同于传统的关系数据库的数据库管理系统的统称，即广义地来说可以把所有不是关系型数据库的数据库统称为NoSQL。 NoSQL 数据库专门构建用于特定的数据模型，并且具有灵活的架构来构建现代应用程序。NoSQL 数据库使用各种数据模型来访问和管理数据。这些类型的数据库专门针对需要大数据量、低延迟和灵活数据模型的应用程序进行了优化，这是通过放宽其他数据库的某些数据一致性限制来实现的。 nosql特点 方便扩展(数据之间没有关系) 大数据量高性能(一秒写8W次，读11W次，nosql的缓存记录级，是一种细粒度的缓存，性能高) 数据类型多样性 string hash list set zset geospatial hyperloglog bitmaps Redis概述定义 Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。 能做什么 内存存储持久化（rdb,aof） 效率高 高数缓存 发布订阅分析 地图信息系统 计时器，计数器（浏览量） … 测试性能redis-benchmark是官方自带的压力测试工具 具体参数 1redis-benchmark -h localhost -p 6379 -c 100 -n 1000 #不是在客户端 而是在redis目录下 100并发1000请求 基础知识 redis默认有16个数据库 可以用select切换数据库 flushdb &#x2F; flushall 删库跑路 redis是单线程的，基于内存操作，cpu不是redis的性能瓶颈，而是机器的内存和网络带宽 QPS 10W+ redis将所有的数据放在内存中处理，所以用单线程操作最快 Redis 键(key) 命令 命令 描述 Redis Type 命令 返回 key 所储存的值的类型。 Redis PEXPIREAT 命令 设置 key 的过期时间亿以毫秒计。 Redis PEXPIREAT 命令 设置 key 过期时间的时间戳(unix timestamp) 以毫秒计 Redis Rename 命令 修改 key 的名称 Redis PERSIST 命令 移除 key 的过期时间，key 将持久保持。 Redis Move 命令 将当前数据库的 key 移动到给定的数据库 db 当中。 Redis RANDOMKEY 命令 从当前数据库中随机返回一个 key 。 Redis Dump 命令 序列化给定 key ，并返回被序列化的值。 Redis TTL 命令 以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)。 Redis Expire 命令 seconds 为给定 key 设置过期时间。 Redis DEL 命令 该命令用于在 key 存在是删除 key。 Redis Pttl 命令 以毫秒为单位返回 key 的剩余的过期时间。 Redis Renamenx 命令 仅当 newkey 不存在时，将 key 改名为 newkey 。 Redis EXISTS 命令 检查给定 key 是否存在。 Redis Expireat 命令 EXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置过期时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。 Redis Keys 命令 查找所有符合给定模式( pattern)的 key 。 Redis 字符串(String) 命令 命令 描述 Redis Setnx 命令 只有在 key 不存在时设置 key 的值。 Redis Getrange 命令 返回 key 中字符串值的子字符 Redis Mset 命令 同时设置一个或多个 key-value 对。 Redis Setex 命令 将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位)。 Redis SET 命令 设置指定 key 的值 Redis Get 命令 获取指定 key 的值。 Redis Getbit 命令 对 key 所储存的字符串值，获取指定偏移量上的位(bit)。 Redis Setbit 命令 对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。 Redis Decr 命令 将 key 中储存的数字值减一。 Redis Decrby 命令 key 所储存的值减去给定的减量值（decrement） 。 Redis Strlen 命令 返回 key 所储存的字符串值的长度。 Redis Msetnx 命令 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。 Redis Incrby 命令 将 key 所储存的值加上给定的增量值（increment） 。 Redis Incrbyfloat 命令 将 key 所储存的值加上给定的浮点增量值（increment） 。 Redis Setrange 命令 用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始。 Redis Psetex 命令 这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，而不是像 SETEX 命令那样，以秒为单位。 Redis Append 命令 如果 key 已经存在并且是一个字符串， APPEND 命令将 value 追加到 key 原来的值的末尾。 Redis Getset 命令 将给定 key 的值设为 value ，并返回 key 的旧值(old value)。 Redis Mget 命令 获取所有(一个或多个)给定 key 的值。 Redis Incr 命令 将 key 中储存的数字值增一。 Redis 哈希(Hash) 命令 命令 描述 Redis Hmset 命令 同时将多个 field-value (域-值)对设置到哈希表 key 中。 Redis Hmget 命令 获取所有给定字段的值 Redis Hset 命令 将哈希表 key 中的字段 field 的值设为 value 。 Redis Hgetall 命令 获取在哈希表中指定 key 的所有字段和值 Redis Hget 命令 获取存储在哈希表中指定字段的值&#x2F;td&gt; Redis Hexists 命令 查看哈希表 key 中，指定的字段是否存在。 Redis Hincrby 命令 为哈希表 key 中的指定字段的整数值加上增量 increment 。 Redis Hlen 命令 获取哈希表中字段的数量 Redis Hdel 命令 删除一个或多个哈希表字段 Redis Hvals 命令 获取哈希表中所有值 Redis Hincrbyfloat 命令 为哈希表 key 中的指定字段的浮点数值加上增量 increment 。 Redis Hkeys 命令 获取所有哈希表中的字段 Redis Hsetnx 命令 只有在字段 field 不存在时，设置哈希表字段的值。 Redis 列表(List) 命令 命令 描述 Redis Lindex 命令 通过索引获取列表中的元素 Redis Rpush 命令 在列表中添加一个或多个值 Redis Lrange 命令 获取列表指定范围内的元素 Redis Rpoplpush 命令 移除列表的最后一个元素，并将该元素添加到另一个列表并返回 Redis Blpop 命令 移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 Redis Brpop 命令 移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 Redis Brpoplpush 命令 从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 Redis Lrem 命令 移除列表元素 Redis Llen 命令 获取列表长度 Redis Ltrim 命令 对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。 Redis Lpop 命令 移出并获取列表的第一个元素 Redis Lpushx 命令 将一个或多个值插入到已存在的列表头部 Redis Linsert 命令 在列表的元素前或者后插入元素 Redis Rpop 命令 移除并获取列表最后一个元素 Redis Lset 命令 通过索引设置列表元素的值 Redis Lpush 命令 将一个或多个值插入到列表头部 Redis Rpushx 命令 为已存在的列表添加值 Redis 集合(Set) 命令 命令 描述 Redis Sunion 命令 返回所有给定集合的并集 Redis Scard 命令 获取集合的成员数 Redis Srandmember 命令 返回集合中一个或多个随机数 Redis Smembers 命令 返回集合中的所有成员 Redis Sinter 命令 返回给定所有集合的交集 Redis Srem 命令 移除集合中一个或多个成员 Redis Smove 命令 将 member 元素从 source 集合移动到 destination 集合 Redis Sadd 命令 向集合添加一个或多个成员 Redis Sismember 命令 判断 member 元素是否是集合 key 的成员 Redis Sdiffstore 命令 返回给定所有集合的差集并存储在 destination 中 Redis Sdiff 命令 返回给定所有集合的差集 Redis Sscan 命令 迭代集合中的元素 Redis Sinterstore 命令 返回给定所有集合的交集并存储在 destination 中 Redis Sunionstore 命令 所有给定集合的并集存储在 destination 集合中 Redis Spop 命令 移除并返回集合中的一个随机元素 Redis 有序集合(sorted set) 命令 命令 描述 Redis Zrevrank 命令 返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序 Redis Zlexcount 命令 在有序集合中计算指定字典区间内成员数量 Redis Zunionstore 命令 计算给定的一个或多个有序集的并集，并存储在新的 key 中 Redis Zremrangebyrank 命令 移除有序集合中给定的排名区间的所有成员 Redis Zcard 命令 获取有序集合的成员数 Redis Zrem 命令 移除有序集合中的一个或多个成员 Redis Zinterstore 命令 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中 Redis Zrank 命令 返回有序集合中指定成员的索引 Redis Zincrby 命令 有序集合中对指定成员的分数加上增量 increment Redis Zrangebyscore 命令 通过分数返回有序集合指定区间内的成员 Redis Zrangebylex 命令 通过字典区间返回有序集合的成员 Redis Zscore 命令 返回有序集中，成员的分数值 Redis Zremrangebyscore 命令 移除有序集合中给定的分数区间的所有成员 Redis Zscan 命令 迭代有序集合中的元素（包括元素成员和元素分值） Redis Zrevrangebyscore 命令 返回有序集中指定分数区间内的成员，分数从高到低排序 Redis Zremrangebylex 命令 移除有序集合中给定的字典区间的所有成员 Redis Zrevrange 命令 返回有序集中指定区间内的成员，通过索引，分数从高到底 Redis Zrange 命令 通过索引区间返回有序集合成指定区间内的成员 Redis Zcount 命令 计算在有序集合中指定区间分数的成员数 Redis Zadd 命令 向有序集合添加一个或多个成员，或者更新已存在成员的分数 Redis 连接 命令 命令 描述 Redis Echo 命令 打印字符串 Redis Select 命令 切换到指定的数据库 Redis Ping 命令 查看服务是否运行 Redis Quit 命令 关闭当前连接 Redis Auth 命令 验证密码是否正确 Redis 服务器 命令 命令 描述 Redis Client Pause 命令 在指定时间内终止运行来自客户端的命令 Redis Debug Object 命令 获取 key 的调试信息 Redis Flushdb 命令 删除当前数据库的所有key Redis Save 命令 异步保存数据到硬盘 Redis Showlog 命令 管理 redis 的慢日志 Redis Lastsave 命令 返回最近一次 Redis 成功将数据保存到磁盘上的时间，以 UNIX 时间戳格式表示 Redis Config Get 命令 获取指定配置参数的值 Redis Command 命令 获取 Redis 命令详情数组 Redis Slaveof 命令 将当前服务器转变为指定服务器的从属服务器(slave server) Redis Debug Segfault 命令 让 Redis 服务崩溃 Redis Flushall 命令 删除所有数据库的所有key Redis Dbsize 命令 返回当前数据库的 key 的数量 Redis Bgrewriteaof 命令 异步执行一个 AOF（AppendOnly File） 文件重写操作 Redis Cluster Slots 命令 获取集群节点的映射数组 Redis Config Set 命令 修改 redis 配置参数，无需重启 Redis Command Info 命令 获取指定 Redis 命令描述的数组 Redis Shutdown 命令 异步保存数据到硬盘，并关闭服务器 Redis Sync 命令 用于复制功能(replication)的内部命令 Redis Client Kill 命令 关闭客户端连接 Redis Role 命令 返回主从实例所属的角色 Redis Monitor 命令 实时打印出 Redis 服务器接收到的命令，调试用 Redis Command Getkeys 命令 获取给定命令的所有键 Redis Client Getname 命令 获取连接的名称 Redis Config Resetstat 命令 重置 INFO 命令中的某些统计数据 Redis Command Count 命令 获取 Redis 命令总数 Redis Time 命令 返回当前服务器时间 Redis Info 命令 获取 Redis 服务器的各种信息和统计数值 Redis Config rewrite 命令 对启动 Redis 服务器时所指定的 redis.conf 配置文件进行改写 Redis Client List 命令 获取连接到服务器的客户端连接列表 Redis Client Setname 命令 设置当前连接的名称 Redis Bgsave 命令 在后台异步保存当前数据库的数据到磁盘 Redis 脚本 命令 命令 描述 Redis Script kill 命令 杀死当前正在运行的 Lua 脚本。 Redis Script Load 命令 将脚本 script 添加到脚本缓存中，但并不立即执行这个脚本。 Redis Eval 命令 执行 Lua 脚本。 Redis Evalsha 命令 执行 Lua 脚本。 Redis Script Exists 命令 查看指定的脚本是否已经被保存在缓存当中。 Redis Script Flush 命令 从脚本缓存中移除所有脚本。 Redis 事务 命令 命令 描述 Redis Exec 命令 执行所有事务块内的命令。 Redis Watch 命令 监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。 Redis Discard 命令 取消事务，放弃执行事务块内的所有命令。 Redis Unwatch 命令 取消 WATCH 命令对所有 key 的监视。 Redis Multi 命令 标记一个事务块的开始。 Redis HyperLogLog 命令 命令 描述 Redis Pgmerge 命令 将多个 HyperLogLog 合并为一个 HyperLogLog Redis Pfadd 命令 添加指定元素到 HyperLogLog 中。 Redis Pfcount 命令 返回给定 HyperLogLog 的基数估算值。 Redis 发布订阅 命令 命令 描述 Redis Unsubscribe 命令 指退订给定的频道。 Redis Subscribe 命令 订阅给定的一个或多个频道的信息。 Redis Pubsub 命令 查看订阅与发布系统状态。 Redis Punsubscribe 命令 退订所有给定模式的频道。 Redis Publish 命令 将信息发送到指定的频道。 Redis Psubscribe 命令 订阅一个或多个符合给定模式的频道。 Redis 地理位置(geo) 命令 命令 描述 Redis GEOHASH 命令 返回一个或多个位置元素的 Geohash 表示 Redis GEOPOS 命令 从key里返回所有给定位置元素的位置（经度和纬度） Redis GEODIST 命令 返回两个给定位置之间的距离 Redis GEORADIUS 命令 以给定的经纬度为中心， 找出某一半径内的元素 Redis GEOADD 命令 将指定的地理空间位置（纬度、经度、名称）添加到指定的key中 Redis GEORADIUSBYMEMBER 命令 找出位于指定范围内的元素，中心点是由给定的位置元素决定 持久化RDB 什么是RDB 在指定时间间隔后，将内存中的数据集快照写入数据库 ；在恢复时候，直接读取快照文件，进行数据的恢复 ； 默认情况下， Redis 将数据库快照保存在名字为 dump.rdb的二进制文件中。文件名可以在配置文件中进行自定义。 工作原理 在进行 RDB 的时候，redis 的主线程是不会做 io 操作的，主线程会 fork 一个子线程来完成该操作； Redis 调用forks。同时拥有父进程和子进程。子进程将数据集写入到一个临时 RDB 文件中。当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益(因为是使用子进程进行写操作，而父进程依然可以接收来自客户端的请求。) 触发机制 save的规则满足的情况下，会自动触发rdb原则 执行flushall命令，也会触发我们的rdb原则 退出redis，也会自动产生rdb文件 save 使用 save 命令，会立刻对当前内存中的数据进行持久化 ,但是会阻塞，也就是不接受其他操作了； 由于 save 命令是同步命令，会占用Redis的主进程。若Redis数据非常多时，save命令执行速度会非常慢，阻塞所有客户端的请求。 flushall命令flushall 命令也会触发持久化 ； bgsave命令bgsave 是异步进行，进行持久化的时候，redis 还可以将继续响应客户端请求 ； 优点： 适合大规模的数据恢复 对数据的完整性要求不高 缺点 需要一定的时间间隔进行操作，如果redis意外宕机了，这个最后一次修改的数据就没有了。 fork进程的时候，会占用一定的内容空间。 AOF 什么是AOF 快照功能（RDB）并不是非常耐久（durable）： 如果 Redis 因为某些原因而造成故障停机， 那么服务器将丢失最近写入、以及未保存到快照中的那些数据。 从 1.1 版本开始， Redis 增加了一种完全耐久的持久化方式： AOF 持久化。 优点 每一次修改都会同步，文件的完整性会更加好 每秒同步一次，可能会丢失一秒的数据 从不同步，效率最高 缺点 相对于数据文件来说，aof远远大于rdb，修复速度比rdb慢！ Aof运行效率也要比rdb慢，所以我们redis默认的配置就是rdb持久化 Redis主从复制 概念 主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点（Master&#x2F;Leader）,后者称为从节点（Slave&#x2F;Follower）， 数据的复制是单向的！只能由主节点复制到从节点（主节点以写为主、从节点以读为主）。 默认情况下，每台Redis服务器都是主节点，一个主节点可以有0个或者多个从节点，但每个从节点只能由一个主节点。 作用 数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余的方式。故障恢复：当主节点故障时，从节点可以暂时替代主节点提供服务，是一种服务冗余的方式负载均衡：在主从复制的基础上，配合读写分离，由主节点进行写操作，从节点进行读操作，分担服务器的负载；尤其是在多读少写的场景下，通过多个从节点分担负载，提高并发量。高可用基石：主从复制还是哨兵和集群能够实施的基础。 为什么使用集群 单台服务器难以负载大量的请求单台服务器故障率高，系统崩坏概率大单台服务器内存容量有限。 缓冲穿透&amp;缓冲击穿&amp;缓冲雪崩缓冲穿透 概念 在默认情况下，用户请求数据时，会先在缓存(Redis)中查找，若没找到即缓存未命中，再在数据库中进行查找，数量少可能问题不大，可是一旦大量的请求数据（例如秒杀场景）缓存都没有命中的话，就会全部转移到数据库上，造成数据库极大的压力，就有可能导致数据库崩溃。网络安全中也有人恶意使用这种手段进行攻击被称为洪水攻击。 解决方法 布隆过滤器 缓存空对象 缓冲击穿 概念 相较于缓存穿透，缓存击穿的目的性更强，一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增。这就是缓存被击穿，只是针对其中某个key的缓存不可用而导致击穿，但是其他的key依然可以使用缓存响应。 比如热搜排行上，一个热点新闻被同时大量访问就可能导致缓存击穿。 解决方法 设置热点数据永不过期 加互斥锁 缓冲雪崩 概念 大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。 解决方法 redis高可用 这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群 限流降级 这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。 数据预热 数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。","categories":[],"tags":[{"name":"-Redis","slug":"Redis","permalink":"https://zjbcxiaotiancai.github.io/xiaowo.github.io/tags/Redis/"}]},{"title":"Go-Xorm","slug":"Go-Xorm","date":"2023-05-18T00:14:49.000Z","updated":"2023-05-18T00:30:38.618Z","comments":true,"path":"2023/05/18/Go-Xorm/","link":"","permalink":"https://zjbcxiaotiancai.github.io/xiaowo.github.io/2023/05/18/Go-Xorm/","excerpt":"","text":"Xorm特性 支持 Struct 和数据库表之间的灵活映射，并支持自动同步 事务支持 同时支持原始SQL语句和ORM操作的混合执行 使用连写来简化调用 支持使用ID, In, Where, Limit, Join, Having, Table, SQL, Cols等函数和结构体等方式作为条件 支持级联加载Struct Schema支持（仅Postgres） 支持缓存 通过 xorm.io&#x2F;reverse 支持根据数据库自动生成 xorm 结构体 支持记录版本（即乐观锁） 通过 xorm.io&#x2F;builder 内置 SQL Builder 支持 上下文缓存支持 支持日志上下文 安装12go get -u github.com/go-sql-driver/mysqlgo get xorm.io/xorm 使用连接数据库1234567891011121314151617181920212223//数据库连接基本信息 var ( username string = &quot;root&quot; password string = &quot;password&quot; ip string = &quot;localhost&quot; port int = 3306 dbName string = &quot;gosql&quot; charset string = &quot;utf8mb4&quot; //数据库字符集 )//构建数据库连接信息dataSourceName :=fmt.Sprintf(&quot;%s:%s@tcp(%s:%d)/%s?charset=%s&quot;, username, password, ip, port, dbName, charset) //这里对数据库连接信息进行拼接engine, err := xorm.NewEngine(&quot;mysql&quot;, dataSourceName)if err != nil &#123; fmt.Printf(&quot;连接失败\\r\\n&quot;) &#125; else &#123; fmt.Printf(&quot;连接成功\\r\\n&quot;) &#125; 创建与表同步的结构体1234567891011121314151617// 与表同步的结构体type User struct &#123; Id int64 Name string Age int Salt string Passwd string `xorm:&quot;varchar(200)&quot;` Created time.Time `xorm:&quot;created&quot;` Updated time.Time `xorm:&quot;updated&quot;`&#125;err = engine.Sync(new(User))if err != nil &#123; fmt.Println(&quot;表结构同步失败！&quot;)&#125; else &#123; fmt.Println(&quot;表结构同步成功！&quot;)&#125; 增1234567891011121314151617181920//数据插入user := User&#123;Id: 0001, Name: &quot;小蜗&quot;, Age: 20, Salt: &quot; &quot;, Passwd: &quot;root&quot;&#125;n, _ := engine.Insert(&amp;user) if n &gt;= 1 &#123; fmt.Println(&quot;插入成功&quot;) &#125;//切片插入var users []Userusers = append(users, User&#123;Id: 0002, Name: &quot;小蜗&quot;, Age: 20, Salt: &quot; &quot;, Passwd: &quot;root&quot;&#125;)users = append(users, User&#123;Id: 0003, Name: &quot;小蜗&quot;, Age: 20, Salt: &quot; &quot;, Passwd: &quot;root&quot;&#125;)n, _ := engine.Insert(&amp;users) if n &gt;= 1 &#123; fmt.Println(&quot;切片插入成功&quot;) &#125;//update deleteuser := User&#123;Name: &quot;小天才&quot;&#125;n, _ := engine.ID(0001).Update(&amp;user) if n &gt;= 1 &#123; fmt.Println(&quot;update 成功&quot;) &#125; 删12345user = User&#123;Id: 0002&#125;n, _ = engine.ID(0002).Delete(&amp;user) if n &gt;= 1 &#123; fmt.Println(&quot;delete 成功&quot;) &#125; exec1engine.Exec(&quot;update user set age = ? where id = ?&quot;, 100, 3) 查12345678910result, _ := engine.Query(&quot;select * from user&quot;)fmt.Println(result)result1, _ := engine.QueryString(&quot;select * from user&quot;)fmt.Println(result1)result2, _ := engine.QueryInterface(&quot;select * from user&quot;)fmt.Println(result2)//getuser := User&#123;Age: 100&#125;engine.Get(&amp;user)fmt.Println(user) 改123456789101112131415161718192021affected, err := engine.ID(1).Update(&amp;user)// UPDATE user SET ... Where id = ?affected, err := engine.Update(&amp;user, &amp;User&#123;Name:name&#125;)// UPDATE user SET ... Where name = ?var ids = []int64&#123;1, 2, 3&#125;affected, err := engine.In(ids).Update(&amp;user)// UPDATE user SET ... Where id IN (?, ?, ?)// force update indicated columns by Colsaffected, err := engine.ID(1).Cols(&quot;age&quot;).Update(&amp;User&#123;Name:name, Age: 12&#125;)// UPDATE user SET age = ?, updated=? Where id = ?// force NOT update indicated columns by Omitaffected, err := engine.ID(1).Omit(&quot;name&quot;).Update(&amp;User&#123;Name:name, Age: 12&#125;)// UPDATE user SET age = ?, updated=? Where id = ?affected, err := engine.ID(1).AllCols().Update(&amp;user)// UPDATE user SET name=?,age=?,salt=?,passwd=?,updated=? Where id = ? 事务什么是事务？ 在操作数据库的时候经常需要处理新增，修改，删除等操作，再进行这些操作的时候往往需要用到事物，在新增，修改，删除出错的时候进行回滚操作。 12345678910111213141516171819202122232425session := engine.NewSession()defer session.Close()// add Begin() before any actionif err := session.Begin(); err != nil &#123; // if returned then will rollback automatically return err&#125;user1 := Userinfo&#123;Username: &quot;xiaoxiao&quot;, Departname: &quot;dev&quot;, Alias: &quot;lunny&quot;, Created: time.Now()&#125;if _, err := session.Insert(&amp;user1); err != nil &#123; return err&#125;user2 := Userinfo&#123;Username: &quot;yyy&quot;&#125;if _, err := session.Where(&quot;id = ?&quot;, 2).Update(&amp;user2); err != nil &#123; return err&#125;if _, err := session.Exec(&quot;delete from userinfo where username = ?&quot;, user2.Username); err != nil &#123; return err&#125;// add Commit() after all actionsreturn session.Commit()","categories":[],"tags":[{"name":"-go","slug":"go","permalink":"https://zjbcxiaotiancai.github.io/xiaowo.github.io/tags/go/"}]},{"title":"Docker","slug":"Docker","date":"2023-05-16T03:10:48.000Z","updated":"2023-05-17T00:45:25.399Z","comments":true,"path":"2023/05/16/Docker/","link":"","permalink":"https://zjbcxiaotiancai.github.io/xiaowo.github.io/2023/05/16/Docker/","excerpt":"","text":"Docker 镜像(Image): docker镜像好比是一个模板，可以通过这个模板创建容器服务 tomcat镜像&#x3D;&#x3D;&gt;run&#x3D;&#x3D;&gt;tomcat01容器（提供服务器） 容器(Contaniner): Docker利用容器技术，独立运行一个或一个组应用。可以理解位一个简易的linux系统 仓库(Repository): 仓库就是存放容器的地方！分为公有仓库和私有仓库 安装docker (centos7为例)1234567891011121314151617181920212223## 卸载旧版本sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine## 安装安装包sudo yum install -y yum-utils## 设置镜像的仓库 阿里云sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo## 更新yumyum makecache fast## 安装docker引擎 -ce社区 -ee企业版sudo yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin## 启动sudo systemctl start docker## 查看版本docker version## 测试 当容器运行时，它会打印一条确认消息并退出。您现在已经成功安装并启动了 Docker 引擎。sudo docker run hello-world 卸载docker123sudo yum remove docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin docker-ce-rootless-extrassudo rm -rf /var/lib/dockersudo rm -rf /var/lib/containerd 底层原理Docker是一个Client-Server结构的系统，Docker的守护进程运行在主机上。通过Socket从客户端访问。Docker-Server接收到Docker-Client的指令，就会执行这个命令！ Docker 常用命令帮助命令123docker version # 显示docker的版本信息docker info # 显示docker的系统信息 包括镜像和容器数量docker 命令 --help # 帮助命令 镜像命令1234docker images # 查看本地主机上的镜像docker search # 搜索镜像docker pull[:tag] # 下载镜像 不注明tag即最新docker rmi # 删除镜像 容器命令下载centos镜像作为测试学习 1234567891011121314151617docker pull centos# docker run[可选参数] image 参数说明 --name=&quot;Name&quot; 容器名字 用于区分容器 --d 后台运行 --it 交互方式运行 进入容器查看内容 --P 随机指定端口 --p 指定容器端口docker run -it centosexit # 停止容器退回主机docker ps # 所有运行的容器Ctrl + q + p # 退回主机不停止容器docker rm 容器id # 删除指定容器docker rm -rf $(docker ps -aq) #删除所有容器docker start 容器id docker restart 容器iddocker stop 容器iddocker kill 容器id # 强制停止 常用其他命令 常见的坑： docker 容器使用后台运行 必须要有一个前台进程 nginx,容器启动后，发现没有提供服务，就会立刻停止 查看日志1docker logs -f -t --tail 容器id 查看镜像源数据1docker inspect 容器id 进入当前正在运行的容器123docker exec -it 容器id /bin/bash #开启新的终端，可以在里面操作#**OR**#docker attach 容器id #进入容器正在执行的终端 拷贝容器内的数据至主机1docker cp 容器id:路径内路径 目的主机路径 commit镜像12docker commit # 提交容器成为一个新的副本docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器ID 目标镜像名:[TAG] Docker-Nginx123456789101112131415161718192021222324252627282930docker pull nginxdocker run -d --name nginx01 -p:3344:80 nginx #3344为linux端口 80为容器端口 curl localhost:3344======================================[root@localhost elijah]# curl localhost:3344&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Welcome to nginx!&lt;/title&gt;&lt;style&gt;html &#123; color-scheme: light dark; &#125;body &#123; width: 35em; margin: 0 auto;font-family: Tahoma, Verdana, Arial, sans-serif; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;&lt;p&gt;If you see this page, the nginx web server is successfully installed andworking. Further configuration is required.&lt;/p&gt;&lt;p&gt;For online documentation and support please refer to&lt;a href=&quot;http://nginx.org/&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;Commercial support is available at&lt;a href=&quot;http://nginx.com/&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;====================================== Docker-TomCat1234567docker run -d -p 3355:8080 --name tomcat01 tomcat:9.0curl localhost:3355======================================[root@localhost elijah]# curl localhost:3355## pull至本地的是tomcat最小版本 缺少部署的项目&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;title&gt;HTTP Status 404 – Not Found&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt;body &#123;font-family:Tahoma,Arial,sans-serif;&#125; h1, h2, h3, b &#123;color:white;background-color:#525D76;&#125; h1 &#123;font-size:22px;&#125; h2 &#123;font-size:16px;&#125; h3 &#123;font-size:14px;&#125; p &#123;font-size:12px;&#125; a &#123;color:black;&#125; .line &#123;height:1px;background-color:#525D76;border:none;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;HTTP Status 404 – Not Found&lt;/h1&gt;&lt;hr class=&quot;line&quot; /&gt;&lt;p&gt;&lt;b&gt;Type&lt;/b&gt; Status Report&lt;/p&gt;&lt;p&gt;&lt;b&gt;Description&lt;/b&gt; The origin server did not find a current representation for the target resource or is not willing to disclose that one exists.&lt;/p&gt;&lt;hr class=&quot;line&quot; /&gt;&lt;h3&gt;Apache Tomcat/9.0.75&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt;====================================== Docker-ES Elasticsearch 暴露的端口很多！ Elasticsearch 十分得耗内存 1.xG Elasticsearch 的数据一般需要挂载到安全目录 12345678910111213141516171819202122docker pull docker.elastic.co/elasticsearch/elasticsearch:7.5.2docker run -p 9200:9200 -p 9300:9300 -d -e &quot;discovery.type=single-node&quot; docker.elastic.co/elasticsearch/elasticsearch:7.5.2======================================[root@localhost elijah]# curl localhost:9200&#123; &quot;name&quot; : &quot;c876dcd60451&quot;, &quot;cluster_name&quot; : &quot;docker-cluster&quot;, &quot;cluster_uuid&quot; : &quot;QhjzNz7JRiSSRzZqVT_PRw&quot;, &quot;version&quot; : &#123; &quot;number&quot; : &quot;7.5.2&quot;, &quot;build_flavor&quot; : &quot;default&quot;, &quot;build_type&quot; : &quot;docker&quot;, &quot;build_hash&quot; : &quot;8bec50e1e0ad29dad5653712cf3bb580cd1afcdf&quot;, &quot;build_date&quot; : &quot;2020-01-15T12:11:52.313576Z&quot;, &quot;build_snapshot&quot; : false, &quot;lucene_version&quot; : &quot;8.3.0&quot;, &quot;minimum_wire_compatibility_version&quot; : &quot;6.8.0&quot;, &quot;minimum_index_compatibility_version&quot; : &quot;6.0.0-beta1&quot; &#125;, &quot;tagline&quot; : &quot;You Know, for Search&quot;&#125;====================================== 可视化portainer12345678docker run -d -p 8088:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer # 测试curl localhost:8088&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; ng-app=&quot;portainer&quot;&gt; # 外网访问 http://ip:8088 容器数据卷目的为了数据持久化和同步操作，将容器内的数据挂载出来 容器与容器也可以数据共享 使用数据卷123456# -vdocker run -it -v 主机目录,容器内目录 ##测试 docker run -it -v /home/ceshi:/home centos /bin/bash docker inspect 容器id Mysql 运行数据库需要数据挂载 12docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql 具名和匿名挂载12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# 匿名挂载-v 容器内路径docker run -d -P --name nginx01 -v /etc/nginx nginx # -P 随机指定端口 # 查看所有volume的情况docker volume lsDRIVER VOLUME NAMElocal 561b81a03506f31d45ada3f9fb7bd8d7c9b5e0f826c877221a17e45d4c80e096local 36083fb6ca083005094cbd49572a0bffeec6daadfbc5ce772909bb00be760882 # 这里发现，这种情况就是匿名挂载，我们在-v 后面只写了容器内的路径，没有写容器外的路径！ # 具名挂载docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx nginx26da1ec7d4994c76e80134d24d82403a254a4e1d84ec65d5f286000105c3da17docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES26da1ec7d499 nginx &quot;/docker-entrypoint.…&quot; 3 seconds ago Up 2 seconds 0.0.0.0:32769-&gt;80/tcp nginx02486de1da03cb nginx &quot;/docker-entrypoint.…&quot; 3 minutes ago Up 3 minutes 0.0.0.0:32768-&gt;80/tcp nginx01docker volume lsDRIVER VOLUME NAMElocal 561b81a03506f31d45ada3f9fb7bd8d7c9b5e0f826c877221a17e45d4c80e096local 36083fb6ca083005094cbd49572a0bffeec6daadfbc5ce772909bb00be760882local juming-nginx # 通过-v 卷名：容器内的路径# 查看一下这个卷# docker volume inspect juming-nginx docker volume inspect juming-nginx[ &#123; &quot;CreatedAt&quot;: &quot;2020-08-12T18:15:21+08:00&quot;, &quot;Driver&quot;: &quot;local&quot;, &quot;Labels&quot;: null, &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/juming-nginx/_data&quot;, &quot;Name&quot;: &quot;juming-nginx&quot;, &quot;Options&quot;: null, &quot;Scope&quot;: &quot;local&quot; &#125;]# 所有docker容器内的卷，没有指定目录的情况下都是在/var/lib/docker/volumes/xxxxx/_data# 我们通过具名挂载可以方便的找到我们的一个卷，大多数情况下使用的是具名挂载# 如何确定是具名挂载还是匿名挂载，还是指定路径挂载！-v 容器内路径 # 匿名挂载-v 卷名:容器内路径 # 具名挂载-v /主机路径:容器内路径 # 指定路径挂载# 通过 -v 容器内容路径 ro rw 改变读写权限ro readonly # 只读rw readwrite # 可读可写 docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:ro nginxdocker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:rw nginx # ro 只要看到ro就说明这个路径只能通过宿主机来操作，容器内容无法操作 数据卷容器多个mysql同步数据！ 123docker run -d -p 3344:3306 -v /etc/mysql/conf.d -v /var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7 docker run -d -p 3344:3306 -v /etc/mysql/conf.d -v /var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql02 --volumes-from mysql01 mysql:5.7 DockerFile dockerfile 就是用来构建docker镜像的构建文件！ 构建步骤 1234&gt;&gt;1.编写一个dockerFile文件&gt;&gt;2.docker build 构建成为一个镜像&gt;&gt;3.docker run 运行镜像&gt;&gt;4.docker push 发布镜像（DockerHub、阿里云镜像） 1234567891011mkdir dockerfilevim dockerfile01FROM centos============VOLUME [&quot;volume01&quot;,&quot;volume02&quot;]CMD echo &quot;-----end-----&quot;CMD /bin/bash============docker build -f dockerfile1 -t xiaowo/centos:1.0 .docker images 指令 # 每行都会提交一个新的镜像层 FROM # 基础镜像，一切从这里开始构建MAINTAINER # 镜像是谁写的， 姓名+邮箱RUN # 镜像构建的时候需要运行的命令ADD # 步骤， tomcat镜像， 这个tomcat压缩包！添加内容WORKDIR # 镜像的工作目录VOLUME # 挂载的目录EXPOSE # 保留端口配置CMD # 指定这个容器启动的时候要运行的命令，只有最后一个会生效可被替代ENTRYPOINT # 指定这个容器启动的时候要运行的命令， 可以追加命令ONBUILD # 当构建一个被继承DockerFile 这个时候就会运行 ONBUILD 的指令，触发指令COPY # 类似ADD, 将我们文件拷贝到镜像中ENV # 构建的时候设置环境变量！ 实战测试 创建一个自己的centos 1234567891011121314151617[root@localhost docker-test-volume]# vim mycentos[root@localhost docker-test-volume]# cat mycentosFROM centos:centos7MAINTAINER XIAOWO&lt;19857178394@163.com&gt;ENV MYPATH /usr/localWORKDIR $MYPATHRUN yum -y install vimRUN yum -y install net-toolsEXPOSE 80CMD echo $MYPATHCMD echo &quot;---end---&quot;CMD /bin/bash [root@localhost docker-test-volume]# docker build -f mycentos -t mycentos:0.1 . Tomcat 12345678910111213141516171819202122FROM centosMAINTAINER xiaowo&lt;19857178394@163.com&gt; COPY readme.txt /usr/local/readme.txt ADD jdk-8u73-linux-x64.tar.gz /usr/local/ADD apache-tomcat-9.0.37.tar.gz /usr/local/ RUN yum -y install vim ENV MYPATH /usr/localWORKDIR $MYPATH ENV JAVA_HOME /usr/local/jdk1.8.0_73ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarENV CATALINA_HOME /usr/local/apache-tomcat-9.0.37ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.37ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin EXPOSE 8080 CMD /usr/local/apache-tomcat-9.0.37/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-9.0.37/bin/logs/catalina.out Docker网络 理解docker0-Link思考一个场景，我们编写了一个微服务，database url &#x3D;ip； 项目不重启，数据ip换掉了，我们希望可以处理这个问题，可以按名字来进行访问容器 12docker run -d -P --name tomcat03 --link tomcat02 tomcat# 3可ping2 2不可ping3 -自定义网络网络模式12345[root@localhost docker-test-volume]# docker network lsNETWORK ID NAME DRIVER SCOPEdda70ac5191c bridge bridge local00d9897200c1 host host local34a89431ba8e none null local bridge 网络模式在该模式中，Docker 守护进程创建了一个虚拟以太网桥 docker0，新建的容器会自动桥接到这个接口，附加在其上的任何网卡之间都能自动转发数据包。 默认情况下，守护进程会创建一对对等虚拟设备接口 veth pair，将其中一个接口设置为容器的 eth0 接口（容器的网卡），另一个接口放置在宿主机的命名空间中，以类似 vethxxx 这样的名字命名，从而将宿主机上的所有容器都连接到这个内部网络上。 host 网络模式host 网络模式需要在创建容器时通过参数 --net host 或者 --network host 指定； 采用 host 网络模式的 Docker Container，可以直接使用宿主机的 IP 地址与外界进行通信，若宿主机的 eth0 是一个公有 IP，那么容器也拥有这个公有 IP。同时容器内服务的端口也可以使用宿主机的端口，无需额外进行 NAT 转换； host 网络模式可以让容器共享宿主机网络栈，这样的好处是外部主机与容器直接通信，但是容器的网络缺少隔离性。 none 网络模式none 网络模式是指禁用网络功能，只有 lo 接口 local 的简写，代表 127.0.0.1，即 localhost 本地环回接口。在创建容器时通过参数 --net none 或者 --network none 指定； none 网络模式即不为 Docker Container 创建任何的网络环境，容器内部就只能使用 loopback 网络设备，不会再有其他的网络资源。可以说 none 模式为 Docke Container 做了极少的网络设定，但是俗话说得好“少即是多”，在没有网络配置的情况下，作为 Docker 开发者，才能在这基础做其他无限多可能的网络定制开发。这也恰巧体现了 Docker 设计理念的开放。 container 网络模式 Container 网络模式是 Docker 中一种较为特别的网络的模式。在创建容器时通过参数 --net container:已运行的容器名称|ID 或者 --network container:已运行的容器名称|ID 指定； 处于这个模式下的 Docker 容器会共享一个网络栈，这样两个容器之间可以使用 localhost 高效快速通信。 Container 网络模式即新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。同样两个容器除了网络方面相同之外，其他的如文件系统、进程列表等还是隔离的。 1234567891011121314151617# 我们直接启动的命令默认有一个 --net bridge，而这个就是我们的docker0docker run -d -P --name tomcat01 tomcatdocker run -d -P --name tomcat01 --net bridge tomcat # docker0特点，默认，容器名不能访问， --link可以打通连接！# 我们可以自定义一个网络！# --driver bridge# --subnet 192.168.0.0/16 可以支持255*255个网络 192.168.0.2 ~ 192.168.255.254 65535# --gateway 192.168.0.1 网关[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet26a5afdf4805d7ee0a660b82244929a4226470d99a179355558dca35a2b983ec[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker network lsNETWORK ID NAME DRIVER SCOPE30d601788862 bridge bridge local226019b14d91 host host local26a5afdf4805 mynet bridge local7496c014f74b none null local","categories":[],"tags":[{"name":"-Docker","slug":"Docker","permalink":"https://zjbcxiaotiancai.github.io/xiaowo.github.io/tags/Docker/"}]},{"title":"基于GO语言-UDP通讯","slug":"基于GO语言-UDP通讯","date":"2023-05-15T03:45:09.000Z","updated":"2023-05-15T04:41:50.742Z","comments":true,"path":"2023/05/15/基于GO语言-UDP通讯/","link":"","permalink":"https://zjbcxiaotiancai.github.io/xiaowo.github.io/2023/05/15/%E5%9F%BA%E4%BA%8EGO%E8%AF%AD%E8%A8%80-UDP%E9%80%9A%E8%AE%AF/","excerpt":"","text":"UDP特点 无连接：只知道对端的IP和端口号就可以发送，不需要实现建立连接。 不可靠：没有确认机制， 没有重传机制。如果因为网络故障该段无法发到对方， UDP协议层也不会给应用层返回任何错误信息。 面向数据报： 应用层交给UDP多长的报文， UDP原样发送既不会拆分，也不会合并。如果发送端调用一次sendto, 发送100个字节, 那么接收端也必须调用对应的一次recvfrom, 接收100个 字节，而不能循环调用10次recvfrom, 每次接收10个字节。所以UDP不能够灵活的控制读写数据的次数和数量。 UDP存在接收缓冲区，但不存在发送缓冲区。 协议https://zhuanlan.zhihu.com/p/357080855 服务端1234567891011121314151617181920212223242526272829package mainimport ( &quot;fmt&quot; &quot;net&quot;)func main() &#123; udp, err := net.ListenUDP(&quot;udp&quot;, &amp;net.UDPAddr&#123; IP: net.IPv4(0, 0, 0, 0), Port: 9999, &#125;) if err != nil &#123; fmt.Println(err) return &#125; defer udp.Close() for &#123; var revfromclient [1024]byte n, addr, err := udp.ReadFromUDP(revfromclient[:]) if err != nil &#123; fmt.Println(err) return &#125; fmt.Printf(&quot;%s client send: %s \\n&quot;, addr, string(revfromclient[:n])) udp.WriteTo([]byte(&quot;OK\\r&quot;), addr) &#125;&#125; 客户端123456789101112131415161718192021222324252627282930313233343536373839404142434445package mainimport ( &quot;bufio&quot; &quot;fmt&quot; &quot;net&quot; &quot;os&quot;)func main() &#123; dial, err := net.Dial(&quot;udp&quot;, &quot;0.0.0.0:9999&quot;) if err != nil &#123; fmt.Println(&quot;网络错误&quot;) return &#125; defer dial.Close() input := bufio.NewReader(os.Stdin) for &#123; s, _ := input.ReadString(&#x27;\\n&#x27;) _, err = dial.Write([]byte(s)) if err != nil &#123; fmt.Println(&quot;发送数据失败&quot;) return &#125; &#125; //接收数据 var b [1024]byte n, err := dial.Read(b[:]) if err != nil &#123; fmt.Println(&quot;接收数据失败&quot;) return &#125; fmt.Println(&quot;接收的消息：&quot;, string(b[:n]))&#125;","categories":[],"tags":[{"name":"-go","slug":"go","permalink":"https://zjbcxiaotiancai.github.io/xiaowo.github.io/tags/go/"}]},{"title":"基于GO语言-tcp扫描","slug":"基于GO语言-tcp扫描","date":"2023-05-14T01:33:36.000Z","updated":"2023-05-14T01:49:44.221Z","comments":true,"path":"2023/05/14/基于GO语言-tcp扫描/","link":"","permalink":"https://zjbcxiaotiancai.github.io/xiaowo.github.io/2023/05/14/%E5%9F%BA%E4%BA%8EGO%E8%AF%AD%E8%A8%80-tcp%E6%89%AB%E6%8F%8F/","excerpt":"","text":"tcp TCP的握手有三个过程，首先客户端发送一个syn的包，表示建立回话的开始，如果客户端收到超时，说明端口可能在防火墙后面。如果服务器应答了syn-ack包，意味着端口被打开了，否则会返回rst包，最后客户端需要另外发送一个ack包，此时连接已经建立。 项目说明 使用标准库中的net.Dial函数实现单个端口的测试 接下来利用flag包配置每个字符串或数字，以此方便修改数据 利用for循环逐一扫描 此时程序运行得极慢 建立协程，加锁 源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546package mainimport ( &quot;flag&quot; &quot;fmt&quot; &quot;net&quot; &quot;sync&quot; &quot;time&quot;)func isOpen(host string, port int, timeout time.Duration) bool &#123; time.Sleep(time.Millisecond * 1) conn, err := net.DialTimeout(&quot;tcp&quot;, fmt.Sprintf(&quot;%s:%d&quot;, host, port), timeout) if err == nil &#123; _ = conn.Close() return true &#125; return false&#125;func main() &#123; hostname := flag.String(&quot;hostname&quot;, &quot;baidu.com&quot;, &quot;hostname to test&quot;) startPort := flag.Int(&quot;startPort&quot;, 80, &quot;the port on which the scanning starts&quot;) endPort := flag.Int(&quot;end-port&quot;, 100, &quot;the port from which the scanning ends&quot;) timeout := flag.Duration(&quot;timeout&quot;, time.Millisecond*200, &quot;timeout&quot;) flag.Parse() ports := []int&#123;&#125; wg := &amp;sync.WaitGroup&#123;&#125; mutex := &amp;sync.Mutex&#123;&#125; for port := *startPort; port &lt;= *endPort; port++ &#123; wg.Add(1) go func(p int) &#123; opened := isOpen(*hostname, p, *timeout) if opened &#123; mutex.Lock() ports = append(ports, p) mutex.Unlock() &#125; wg.Done() &#125;(port) &#125; wg.Wait() fmt.Printf(&quot;opened.ports:%v\\n&quot;, ports)&#125; 本文转自：https://mp.weixin.qq.com/s/OhS_RQZojJbkenOSS_tEng","categories":[],"tags":[{"name":"-go","slug":"go","permalink":"https://zjbcxiaotiancai.github.io/xiaowo.github.io/tags/go/"}]},{"title":"Modbus","slug":"modbus","date":"2023-04-23T12:00:55.000Z","updated":"2023-04-23T12:20:19.597Z","comments":true,"path":"2023/04/23/modbus/","link":"","permalink":"https://zjbcxiaotiancai.github.io/xiaowo.github.io/2023/04/23/modbus/","excerpt":"","text":"modbus ModbusASCLL ModbusRTU - 二进制编码 - CRC错误校验 ModbusTCP&#x2F;IP RTUModbus-RTU模式是指当控制器设为在Modbus网络上以RTU（远程终端模式）模式通信，在消息中的每个8Bit包含两个4Bit的十六进制字符。 1、信息帧发送至少要以3.5个字符时间的停顿间隔开始。在最后一个字符传输字符之后，一个至少3.5个字符时间的停顿标定了信息帧的结束。一个新的信息帧可在此停顿之后开始。如果一个新消息在小于3.5个字符时间内接着前个消息开始，接受的设备将认为它是前一信息帧的延续，这将导致CRC码的值出错。 2、整个信息帧必须作为一连续的流传输。如果在帧完成之前有超过1.5字符时间的停顿时间，接受设备将刷新不完整的信息帧并认为存在丢包现象。 功能码 01 读线圈状态 位操作 读单个或多个 02 读离散输入状态 位操作 读单个或多个 03 读保持寄存器 字操作 读单个或多个 04 读输入寄存器 字操作 读单个或多个 05 写单个线圈 位操作 单个 06 写单个保持寄存器 字操作 单个 15 写多个线圈 位操作 多个 16 写多个保持寄存器 字操作 多个 example code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131//GPIO9 is RXD1//GPIO10 is TXD1//帧结构 = 地址 + 功能码+ 数据 + 校验 = slaveID + 0X03 + 0X0#include &quot;DHT.h&quot;#include &lt;HardwareSerial.h&gt;#define DHTPIN 4 #define DHTTYPE DHT11DHT dht(DHTPIN, DHTTYPE);HardwareSerial SerialPort(1); // use UART1#define bufferSize 255 //一帧数据的最大字节数量 报文最大数量#define baudrate 9600 //定义通讯波特率#define slaveID 0x07 //定义modbus RTU从站站号#define modbusDataSize 100 //定义modbus数据库空间大小#define N 5void setup() &#123; Serial.begin(115200); Serial1.begin(9600, SERIAL_8N1, 35, 33); pinMode(32,OUTPUT); digitalWrite(32, LOW); dht.begin();&#125;void loop() &#123; //延时 unsigned int characterTime; //数据缓冲区定义 unsigned char frame[bufferSize]; //接收到的数据原始CRC unsigned int receivedCrc; //接收到的数据长度 unsigned char address=0; unsigned char temp_h;//温度整数部分 unsigned char temp_l;//温度小数部分 //读取DHT11温度 float h = dht.readHumidity(); // Read temperature as Celsius (the default) float t = dht.readTemperature(); // Read temperature as Fahrenheit (isFahrenheit = true) float f = dht.readTemperature(true); // Check if any reads failed and exit early (to try again). if (isnan(h) || isnan(t) || isnan(f)) &#123; Serial.println(F(&quot;Failed to read from DHT sensor!&quot;)); return; &#125; temp_h=(unsigned char ) t; temp_l=0x00; delay(100); //延时1.5个字符宽度 characterTime = 15000000/baudrate; //如果串口缓冲区数据量大于0进入条件 while(Serial1.available()&gt;0) &#123; //接收的数据量应小于一帧数据的最大字节数量 if(address&lt;bufferSize) &#123; frame[address]=Serial1.read(); Serial.write(frame[address]); address++; &#125; else &#123; //清空缓冲区 Serial1.read(); &#125; //延迟 delayMicroseconds(characterTime); //数据读取完成 if(Serial1.available()==0) &#123; //校验CRC unsigned short internalCrc = ModRTU_CRC((char*)frame, address-2); internalCrc &gt;&gt; 1; unsigned char high = internalCrc&amp;0xFF; unsigned char low = internalCrc&gt;&gt;8; Serial.write(&amp;frame[0], N+2); //校验通过 if(low==frame[address - 1]&amp;&amp;high==frame[address - 2]) &#123; unsigned char slaveCode = frame[0]; //设备号匹配，兼容广播模式 if(slaveCode==slaveID||slaveCode==0) &#123; //检查功能码 unsigned char funcCode = frame[1]; if(funcCode==3) &#123; //组装返回的数据 frame[2] = 0x02; frame[3] = temp_h; frame[4] = temp_l; //frame[5] = 0x00; //frame[6] = val; &#125; &#125; &#125; internalCrc = ModRTU_CRC((char*)frame, N); internalCrc &gt;&gt; 1; frame[N] = internalCrc&amp;0xFF; frame[N+1] = internalCrc&gt;&gt;8; digitalWrite(32, HIGH); Serial1.write(&amp;frame[0], N+2); Serial.write(&amp;frame[0], N+2); delay(10); digitalWrite(32, LOW); &#125; &#125;&#125;unsigned int ModRTU_CRC(char * buf, int len)&#123; unsigned int crc = 0xFFFF; for (int pos = 0; pos &lt; len; pos++) &#123; crc ^= (unsigned int)buf[pos]; for (int i = 8; i != 0; i--) &#123; if ((crc &amp; 0x0001) != 0) &#123; crc &gt;&gt;= 1; crc ^= 0xA001; &#125; else crc &gt;&gt;= 1; &#125; &#125; return crc; &#125;","categories":[],"tags":[{"name":"-通信","slug":"通信","permalink":"https://zjbcxiaotiancai.github.io/xiaowo.github.io/tags/%E9%80%9A%E4%BF%A1/"}]},{"title":"HEXO","slug":"HEXO","date":"2023-04-19T03:30:39.000Z","updated":"2023-04-23T12:20:29.784Z","comments":true,"path":"2023/04/19/HEXO/","link":"","permalink":"https://zjbcxiaotiancai.github.io/xiaowo.github.io/2023/04/19/HEXO/","excerpt":"","text":"Welcome to my first Hexo! If you get any problems when using Hexo, you can ask me on GitHub. HOW TO How to start your own HEXO blog安装Node.js此次所有内容都在nodejs的环境下搭建nodejs检测是否安装成功 1$ node -v 安装gitgit 安装hexo1$ npm install -g hexo-cli 初始化hexo文件夹1234567$ mkdir blog$ hexo init blog$ cd blog$ npm install$ hexo clean$ hexo g $ hexo s 此时进入4000端口就能访问到默认界面连接到github创建以 github名.github.io 形式的库并通过 12345$ npm install hexo-deployer-git --save #安装依赖$ git config --global user.name &quot;GitHub 用户名&quot;$ git config --global user.email &quot;GitHub 邮箱&quot;$ ssh-keygen -t rsa -C &quot;GitHub 邮箱&quot; #将得到的ssh加入到github主页$ ssh -T git@github.com #显示 “Hi xxx! You&#x27;ve successfully……” 即连接成功","categories":[],"tags":[{"name":"-web","slug":"web","permalink":"https://zjbcxiaotiancai.github.io/xiaowo.github.io/tags/web/"}]}],"categories":[],"tags":[{"name":"-Redis","slug":"Redis","permalink":"https://zjbcxiaotiancai.github.io/xiaowo.github.io/tags/Redis/"},{"name":"-go","slug":"go","permalink":"https://zjbcxiaotiancai.github.io/xiaowo.github.io/tags/go/"},{"name":"-Docker","slug":"Docker","permalink":"https://zjbcxiaotiancai.github.io/xiaowo.github.io/tags/Docker/"},{"name":"-通信","slug":"通信","permalink":"https://zjbcxiaotiancai.github.io/xiaowo.github.io/tags/%E9%80%9A%E4%BF%A1/"},{"name":"-web","slug":"web","permalink":"https://zjbcxiaotiancai.github.io/xiaowo.github.io/tags/web/"}]}