{"meta":{"title":"小蜗的博客","subtitle":"my blog","description":"this is my blog","author":"Elijah","url":"https://zjbcxiaotiancai.github.io/xiaowo.github.io","root":"/"},"pages":[{"title":"about","date":"2023-04-21T03:04:24.000Z","updated":"2023-04-21T03:04:24.257Z","comments":true,"path":"about/index.html","permalink":"https://zjbcxiaotiancai.github.io/xiaowo.github.io/about/index.html","excerpt":"","text":""},{"title":"archives","date":"2023-04-21T03:09:30.000Z","updated":"2023-04-21T03:09:30.600Z","comments":true,"path":"archives/index.html","permalink":"https://zjbcxiaotiancai.github.io/xiaowo.github.io/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2023-04-21T03:05:18.000Z","updated":"2023-04-21T03:05:18.068Z","comments":true,"path":"categories/index.html","permalink":"https://zjbcxiaotiancai.github.io/xiaowo.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-04-21T03:04:58.000Z","updated":"2023-04-21T03:04:58.100Z","comments":true,"path":"tags/index.html","permalink":"https://zjbcxiaotiancai.github.io/xiaowo.github.io/tags/index.html","excerpt":"","text":""},{"title":"friends","date":"2023-04-21T03:04:49.000Z","updated":"2023-04-21T03:04:49.694Z","comments":true,"path":"friends/index.html","permalink":"https://zjbcxiaotiancai.github.io/xiaowo.github.io/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"Docker","slug":"Docker","date":"2023-05-16T03:10:48.000Z","updated":"2023-05-16T13:36:18.180Z","comments":true,"path":"2023/05/16/Docker/","link":"","permalink":"https://zjbcxiaotiancai.github.io/xiaowo.github.io/2023/05/16/Docker/","excerpt":"","text":"Docker 镜像（Image）： docker镜像好比是一个模板，可以通过这个模板创建容器服务 tomcat镜像&#x3D;&#x3D;&gt;run&#x3D;&#x3D;&gt;tomcat01容器（提供服务器） **容器(Contaniner)**： Docker利用容器技术，独立运行一个或一个组应用。可以理解位一个简易的linux系统 **仓库(Repository)**： 仓库就是存放容器的地方！分为公有仓库和私有仓库 安装docker (centos7为例)1234567891011121314151617181920212223## 卸载旧版本sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine## 安装安装包sudo yum install -y yum-utils## 设置镜像的仓库 阿里云sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo## 更新yumyum makecache fast## 安装docker引擎 -ce社区 -ee企业版sudo yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin## 启动sudo systemctl start docker## 查看版本docker version## 测试 当容器运行时，它会打印一条确认消息并退出。您现在已经成功安装并启动了 Docker 引擎。sudo docker run hello-world 卸载docker123sudo yum remove docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin docker-ce-rootless-extrassudo rm -rf /var/lib/dockersudo rm -rf /var/lib/containerd 底层原理Docker是一个Client-Server结构的系统，Docker的守护进程运行在主机上。通过Socket从客户端访问。Docker-Server接收到Docker-Client的指令，就会执行这个命令！ Docker 常用命令帮助命令123docker version # 显示docker的版本信息docker info # 显示docker的系统信息 包括镜像和容器数量docker 命令 --help # 帮助命令 镜像命令1234docker images # 查看本地主机上的镜像docker search # 搜索镜像docker pull[:tag] # 下载镜像 不注明tag即最新docker rmi # 删除镜像 容器命令下载centos镜像作为测试学习 1234567891011121314151617docker pull centos# docker run[可选参数] image 参数说明 --name=&quot;Name&quot; 容器名字 用于区分容器 --d 后台运行 --it 交互方式运行 进入容器查看内容 --P 随机指定端口 --p 指定容器端口docker run -it centosexit # 停止容器退回主机docker ps # 所有运行的容器Ctrl + q + p # 退回主机不停止容器docker rm 容器id # 删除指定容器docker rm -rf $(docker ps -aq) #删除所有容器docker start 容器id docker restart 容器iddocker stop 容器iddocker kill 容器id # 强制停止 常用其他命令 常见的坑： docker 容器使用后台运行 必须要有一个前台进程 nginx,容器启动后，发现没有提供服务，就会立刻停止 查看日志1docker logs -f -t --tail 容器id 查看镜像源数据1docker inspect 容器id 进入当前正在运行的容器123docker exec -it 容器id /bin/bash #开启新的终端，可以在里面操作#**OR**#docker attach 容器id #进入容器正在执行的终端 拷贝容器内的数据至主机1docker cp 容器id:路径内路径 目的主机路径 commit镜像12docker commit # 提交容器成为一个新的副本docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器ID 目标镜像名:[TAG] Docker-Nginx123456789101112131415161718192021222324252627282930docker pull nginxdocker run -d --name nginx01 -p:3344:80 nginx #3344为linux端口 80为容器端口 curl localhost:3344======================================[root@localhost elijah]# curl localhost:3344&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Welcome to nginx!&lt;/title&gt;&lt;style&gt;html &#123; color-scheme: light dark; &#125;body &#123; width: 35em; margin: 0 auto;font-family: Tahoma, Verdana, Arial, sans-serif; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;&lt;p&gt;If you see this page, the nginx web server is successfully installed andworking. Further configuration is required.&lt;/p&gt;&lt;p&gt;For online documentation and support please refer to&lt;a href=&quot;http://nginx.org/&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;Commercial support is available at&lt;a href=&quot;http://nginx.com/&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;====================================== Docker-TomCat1234567docker run -d -p 3355:8080 --name tomcat01 tomcat:9.0curl localhost:3355======================================[root@localhost elijah]# curl localhost:3355## pull至本地的是tomcat最小版本 缺少部署的项目&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;title&gt;HTTP Status 404 – Not Found&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt;body &#123;font-family:Tahoma,Arial,sans-serif;&#125; h1, h2, h3, b &#123;color:white;background-color:#525D76;&#125; h1 &#123;font-size:22px;&#125; h2 &#123;font-size:16px;&#125; h3 &#123;font-size:14px;&#125; p &#123;font-size:12px;&#125; a &#123;color:black;&#125; .line &#123;height:1px;background-color:#525D76;border:none;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;HTTP Status 404 – Not Found&lt;/h1&gt;&lt;hr class=&quot;line&quot; /&gt;&lt;p&gt;&lt;b&gt;Type&lt;/b&gt; Status Report&lt;/p&gt;&lt;p&gt;&lt;b&gt;Description&lt;/b&gt; The origin server did not find a current representation for the target resource or is not willing to disclose that one exists.&lt;/p&gt;&lt;hr class=&quot;line&quot; /&gt;&lt;h3&gt;Apache Tomcat/9.0.75&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt;====================================== Docker-ES Elasticsearch 暴露的端口很多！ Elasticsearch 十分得耗内存 1.xG Elasticsearch 的数据一般需要挂载到安全目录 12345678910111213141516171819202122docker pull docker.elastic.co/elasticsearch/elasticsearch:7.5.2docker run -p 9200:9200 -p 9300:9300 -d -e &quot;discovery.type=single-node&quot; docker.elastic.co/elasticsearch/elasticsearch:7.5.2======================================[root@localhost elijah]# curl localhost:9200&#123; &quot;name&quot; : &quot;c876dcd60451&quot;, &quot;cluster_name&quot; : &quot;docker-cluster&quot;, &quot;cluster_uuid&quot; : &quot;QhjzNz7JRiSSRzZqVT_PRw&quot;, &quot;version&quot; : &#123; &quot;number&quot; : &quot;7.5.2&quot;, &quot;build_flavor&quot; : &quot;default&quot;, &quot;build_type&quot; : &quot;docker&quot;, &quot;build_hash&quot; : &quot;8bec50e1e0ad29dad5653712cf3bb580cd1afcdf&quot;, &quot;build_date&quot; : &quot;2020-01-15T12:11:52.313576Z&quot;, &quot;build_snapshot&quot; : false, &quot;lucene_version&quot; : &quot;8.3.0&quot;, &quot;minimum_wire_compatibility_version&quot; : &quot;6.8.0&quot;, &quot;minimum_index_compatibility_version&quot; : &quot;6.0.0-beta1&quot; &#125;, &quot;tagline&quot; : &quot;You Know, for Search&quot;&#125;====================================== 可视化portainer12345678docker run -d -p 8088:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer # 测试curl localhost:8088&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; ng-app=&quot;portainer&quot;&gt; # 外网访问 http://ip:8088 容器数据卷目的为了数据持久化和同步操作，将容器内的数据挂载出来 容器与容器也可以数据共享 使用数据卷123456# -vdocker run -it -v 主机目录,容器内目录 ##测试 docker run -it -v /home/ceshi:/home centos /bin/bash docker inspect 容器id Mysql 运行数据库需要数据挂载 12docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql 具名和匿名挂载12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# 匿名挂载-v 容器内路径docker run -d -P --name nginx01 -v /etc/nginx nginx # -P 随机指定端口 # 查看所有volume的情况docker volume lsDRIVER VOLUME NAMElocal 561b81a03506f31d45ada3f9fb7bd8d7c9b5e0f826c877221a17e45d4c80e096local 36083fb6ca083005094cbd49572a0bffeec6daadfbc5ce772909bb00be760882 # 这里发现，这种情况就是匿名挂载，我们在-v 后面只写了容器内的路径，没有写容器外的路径！ # 具名挂载docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx nginx26da1ec7d4994c76e80134d24d82403a254a4e1d84ec65d5f286000105c3da17docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES26da1ec7d499 nginx &quot;/docker-entrypoint.…&quot; 3 seconds ago Up 2 seconds 0.0.0.0:32769-&gt;80/tcp nginx02486de1da03cb nginx &quot;/docker-entrypoint.…&quot; 3 minutes ago Up 3 minutes 0.0.0.0:32768-&gt;80/tcp nginx01docker volume lsDRIVER VOLUME NAMElocal 561b81a03506f31d45ada3f9fb7bd8d7c9b5e0f826c877221a17e45d4c80e096local 36083fb6ca083005094cbd49572a0bffeec6daadfbc5ce772909bb00be760882local juming-nginx # 通过-v 卷名：容器内的路径# 查看一下这个卷# docker volume inspect juming-nginx docker volume inspect juming-nginx[ &#123; &quot;CreatedAt&quot;: &quot;2020-08-12T18:15:21+08:00&quot;, &quot;Driver&quot;: &quot;local&quot;, &quot;Labels&quot;: null, &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/juming-nginx/_data&quot;, &quot;Name&quot;: &quot;juming-nginx&quot;, &quot;Options&quot;: null, &quot;Scope&quot;: &quot;local&quot; &#125;]# 所有docker容器内的卷，没有指定目录的情况下都是在/var/lib/docker/volumes/xxxxx/_data# 我们通过具名挂载可以方便的找到我们的一个卷，大多数情况下使用的是具名挂载# 如何确定是具名挂载还是匿名挂载，还是指定路径挂载！-v 容器内路径 # 匿名挂载-v 卷名:容器内路径 # 具名挂载-v /主机路径:容器内路径 # 指定路径挂载# 通过 -v 容器内容路径 ro rw 改变读写权限ro readonly # 只读rw readwrite # 可读可写 docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:ro nginxdocker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:rw nginx # ro 只要看到ro就说明这个路径只能通过宿主机来操作，容器内容无法操作 数据卷容器多个mysql同步数据！ 123docker run -d -p 3344:3306 -v /etc/mysql/conf.d -v /var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7 docker run -d -p 3344:3306 -v /etc/mysql/conf.d -v /var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql02 --volumes-from mysql01 mysql:5.7 DockerFile dockerfile 就是用来构建docker镜像的构建文件！ 构建步骤 1234&gt;&gt;1.编写一个dockerFile文件&gt;&gt;2.docker build 构建成为一个镜像&gt;&gt;3.docker run 运行镜像&gt;&gt;4.docker push 发布镜像（DockerHub、阿里云镜像） 1234567891011mkdir dockerfilevim dockerfile01FROM centos============VOLUME [&quot;volume01&quot;,&quot;volume02&quot;]CMD echo &quot;-----end-----&quot;CMD /bin/bash============docker build -f dockerfile1 -t xiaowo/centos:1.0 .docker images 指令 # 每行都会提交一个新的镜像层 FROM # 基础镜像，一切从这里开始构建MAINTAINER # 镜像是谁写的， 姓名+邮箱RUN # 镜像构建的时候需要运行的命令ADD # 步骤， tomcat镜像， 这个tomcat压缩包！添加内容WORKDIR # 镜像的工作目录VOLUME # 挂载的目录EXPOSE # 保留端口配置CMD # 指定这个容器启动的时候要运行的命令，只有最后一个会生效可被替代ENTRYPOINT # 指定这个容器启动的时候要运行的命令， 可以追加命令ONBUILD # 当构建一个被继承DockerFile 这个时候就会运行 ONBUILD 的指令，触发指令COPY # 类似ADD, 将我们文件拷贝到镜像中ENV # 构建的时候设置环境变量！ 实战测试 创建一个自己的centos 1234567891011121314151617[root@localhost docker-test-volume]# vim mycentos[root@localhost docker-test-volume]# cat mycentosFROM centos:centos7MAINTAINER XIAOWO&lt;19857178394@163.com&gt;ENV MYPATH /usr/localWORKDIR $MYPATHRUN yum -y install vimRUN yum -y install net-toolsEXPOSE 80CMD echo $MYPATHCMD echo &quot;---end---&quot;CMD /bin/bash [root@localhost docker-test-volume]# docker build -f mycentos -t mycentos:0.1 . Tomcat 12345678910111213141516171819202122FROM centosMAINTAINER xiaowo&lt;19857178394@163.com&gt; COPY readme.txt /usr/local/readme.txt ADD jdk-8u73-linux-x64.tar.gz /usr/local/ADD apache-tomcat-9.0.37.tar.gz /usr/local/ RUN yum -y install vim ENV MYPATH /usr/localWORKDIR $MYPATH ENV JAVA_HOME /usr/local/jdk1.8.0_73ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarENV CATALINA_HOME /usr/local/apache-tomcat-9.0.37ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.37ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin EXPOSE 8080 CMD /usr/local/apache-tomcat-9.0.37/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-9.0.37/bin/logs/catalina.out Docker网络 理解docker0-Link思考一个场景，我们编写了一个微服务，database url &#x3D;ip； 项目不重启，数据ip换掉了，我们希望可以处理这个问题，可以按名字来进行访问容器 12docker run -d -P --name tomcat03 --link tomcat02 tomcat# 3可ping2 2不可ping3 -自定义网络网络模式12345[root@localhost docker-test-volume]# docker network lsNETWORK ID NAME DRIVER SCOPEdda70ac5191c bridge bridge local00d9897200c1 host host local34a89431ba8e none null local bridge 网络模式在该模式中，Docker 守护进程创建了一个虚拟以太网桥 docker0，新建的容器会自动桥接到这个接口，附加在其上的任何网卡之间都能自动转发数据包。 默认情况下，守护进程会创建一对对等虚拟设备接口 veth pair，将其中一个接口设置为容器的 eth0 接口（容器的网卡），另一个接口放置在宿主机的命名空间中，以类似 vethxxx 这样的名字命名，从而将宿主机上的所有容器都连接到这个内部网络上。 host 网络模式host 网络模式需要在创建容器时通过参数 --net host 或者 --network host 指定； 采用 host 网络模式的 Docker Container，可以直接使用宿主机的 IP 地址与外界进行通信，若宿主机的 eth0 是一个公有 IP，那么容器也拥有这个公有 IP。同时容器内服务的端口也可以使用宿主机的端口，无需额外进行 NAT 转换； host 网络模式可以让容器共享宿主机网络栈，这样的好处是外部主机与容器直接通信，但是容器的网络缺少隔离性。 none 网络模式none 网络模式是指禁用网络功能，只有 lo 接口 local 的简写，代表 127.0.0.1，即 localhost 本地环回接口。在创建容器时通过参数 --net none 或者 --network none 指定； none 网络模式即不为 Docker Container 创建任何的网络环境，容器内部就只能使用 loopback 网络设备，不会再有其他的网络资源。可以说 none 模式为 Docke Container 做了极少的网络设定，但是俗话说得好“少即是多”，在没有网络配置的情况下，作为 Docker 开发者，才能在这基础做其他无限多可能的网络定制开发。这也恰巧体现了 Docker 设计理念的开放。 container 网络模式 Container 网络模式是 Docker 中一种较为特别的网络的模式。在创建容器时通过参数 --net container:已运行的容器名称|ID 或者 --network container:已运行的容器名称|ID 指定； 处于这个模式下的 Docker 容器会共享一个网络栈，这样两个容器之间可以使用 localhost 高效快速通信。 Container 网络模式即新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。同样两个容器除了网络方面相同之外，其他的如文件系统、进程列表等还是隔离的。 1234567891011121314151617# 我们直接启动的命令默认有一个 --net bridge，而这个就是我们的docker0docker run -d -P --name tomcat01 tomcatdocker run -d -P --name tomcat01 --net bridge tomcat # docker0特点，默认，容器名不能访问， --link可以打通连接！# 我们可以自定义一个网络！# --driver bridge# --subnet 192.168.0.0/16 可以支持255*255个网络 192.168.0.2 ~ 192.168.255.254 65535# --gateway 192.168.0.1 网关[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet26a5afdf4805d7ee0a660b82244929a4226470d99a179355558dca35a2b983ec[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker network lsNETWORK ID NAME DRIVER SCOPE30d601788862 bridge bridge local226019b14d91 host host local26a5afdf4805 mynet bridge local7496c014f74b none null local","categories":[],"tags":[{"name":"-Docker","slug":"Docker","permalink":"https://zjbcxiaotiancai.github.io/xiaowo.github.io/tags/Docker/"}]},{"title":"基于GO语言-UDP通讯","slug":"基于GO语言-UDP通讯","date":"2023-05-15T03:45:09.000Z","updated":"2023-05-15T04:41:50.742Z","comments":true,"path":"2023/05/15/基于GO语言-UDP通讯/","link":"","permalink":"https://zjbcxiaotiancai.github.io/xiaowo.github.io/2023/05/15/%E5%9F%BA%E4%BA%8EGO%E8%AF%AD%E8%A8%80-UDP%E9%80%9A%E8%AE%AF/","excerpt":"","text":"UDP特点 无连接：只知道对端的IP和端口号就可以发送，不需要实现建立连接。 不可靠：没有确认机制， 没有重传机制。如果因为网络故障该段无法发到对方， UDP协议层也不会给应用层返回任何错误信息。 面向数据报： 应用层交给UDP多长的报文， UDP原样发送既不会拆分，也不会合并。如果发送端调用一次sendto, 发送100个字节, 那么接收端也必须调用对应的一次recvfrom, 接收100个 字节，而不能循环调用10次recvfrom, 每次接收10个字节。所以UDP不能够灵活的控制读写数据的次数和数量。 UDP存在接收缓冲区，但不存在发送缓冲区。 协议https://zhuanlan.zhihu.com/p/357080855 服务端1234567891011121314151617181920212223242526272829package mainimport ( &quot;fmt&quot; &quot;net&quot;)func main() &#123; udp, err := net.ListenUDP(&quot;udp&quot;, &amp;net.UDPAddr&#123; IP: net.IPv4(0, 0, 0, 0), Port: 9999, &#125;) if err != nil &#123; fmt.Println(err) return &#125; defer udp.Close() for &#123; var revfromclient [1024]byte n, addr, err := udp.ReadFromUDP(revfromclient[:]) if err != nil &#123; fmt.Println(err) return &#125; fmt.Printf(&quot;%s client send: %s \\n&quot;, addr, string(revfromclient[:n])) udp.WriteTo([]byte(&quot;OK\\r&quot;), addr) &#125;&#125; 客户端123456789101112131415161718192021222324252627282930313233343536373839404142434445package mainimport ( &quot;bufio&quot; &quot;fmt&quot; &quot;net&quot; &quot;os&quot;)func main() &#123; dial, err := net.Dial(&quot;udp&quot;, &quot;0.0.0.0:9999&quot;) if err != nil &#123; fmt.Println(&quot;网络错误&quot;) return &#125; defer dial.Close() input := bufio.NewReader(os.Stdin) for &#123; s, _ := input.ReadString(&#x27;\\n&#x27;) _, err = dial.Write([]byte(s)) if err != nil &#123; fmt.Println(&quot;发送数据失败&quot;) return &#125; &#125; //接收数据 var b [1024]byte n, err := dial.Read(b[:]) if err != nil &#123; fmt.Println(&quot;接收数据失败&quot;) return &#125; fmt.Println(&quot;接收的消息：&quot;, string(b[:n]))&#125;","categories":[],"tags":[{"name":"-go","slug":"go","permalink":"https://zjbcxiaotiancai.github.io/xiaowo.github.io/tags/go/"}]},{"title":"基于GO语言-tcp扫描","slug":"基于GO语言-tcp扫描","date":"2023-05-14T01:33:36.000Z","updated":"2023-05-14T01:49:44.221Z","comments":true,"path":"2023/05/14/基于GO语言-tcp扫描/","link":"","permalink":"https://zjbcxiaotiancai.github.io/xiaowo.github.io/2023/05/14/%E5%9F%BA%E4%BA%8EGO%E8%AF%AD%E8%A8%80-tcp%E6%89%AB%E6%8F%8F/","excerpt":"","text":"tcp TCP的握手有三个过程，首先客户端发送一个syn的包，表示建立回话的开始，如果客户端收到超时，说明端口可能在防火墙后面。如果服务器应答了syn-ack包，意味着端口被打开了，否则会返回rst包，最后客户端需要另外发送一个ack包，此时连接已经建立。 项目说明 使用标准库中的net.Dial函数实现单个端口的测试 接下来利用flag包配置每个字符串或数字，以此方便修改数据 利用for循环逐一扫描 此时程序运行得极慢 建立协程，加锁 源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546package mainimport ( &quot;flag&quot; &quot;fmt&quot; &quot;net&quot; &quot;sync&quot; &quot;time&quot;)func isOpen(host string, port int, timeout time.Duration) bool &#123; time.Sleep(time.Millisecond * 1) conn, err := net.DialTimeout(&quot;tcp&quot;, fmt.Sprintf(&quot;%s:%d&quot;, host, port), timeout) if err == nil &#123; _ = conn.Close() return true &#125; return false&#125;func main() &#123; hostname := flag.String(&quot;hostname&quot;, &quot;baidu.com&quot;, &quot;hostname to test&quot;) startPort := flag.Int(&quot;startPort&quot;, 80, &quot;the port on which the scanning starts&quot;) endPort := flag.Int(&quot;end-port&quot;, 100, &quot;the port from which the scanning ends&quot;) timeout := flag.Duration(&quot;timeout&quot;, time.Millisecond*200, &quot;timeout&quot;) flag.Parse() ports := []int&#123;&#125; wg := &amp;sync.WaitGroup&#123;&#125; mutex := &amp;sync.Mutex&#123;&#125; for port := *startPort; port &lt;= *endPort; port++ &#123; wg.Add(1) go func(p int) &#123; opened := isOpen(*hostname, p, *timeout) if opened &#123; mutex.Lock() ports = append(ports, p) mutex.Unlock() &#125; wg.Done() &#125;(port) &#125; wg.Wait() fmt.Printf(&quot;opened.ports:%v\\n&quot;, ports)&#125; 本文转自：https://mp.weixin.qq.com/s/OhS_RQZojJbkenOSS_tEng","categories":[],"tags":[{"name":"-go","slug":"go","permalink":"https://zjbcxiaotiancai.github.io/xiaowo.github.io/tags/go/"}]},{"title":"Modbus","slug":"modbus","date":"2023-04-23T12:00:55.000Z","updated":"2023-04-23T12:20:19.597Z","comments":true,"path":"2023/04/23/modbus/","link":"","permalink":"https://zjbcxiaotiancai.github.io/xiaowo.github.io/2023/04/23/modbus/","excerpt":"","text":"modbus ModbusASCLL ModbusRTU - 二进制编码 - CRC错误校验 ModbusTCP&#x2F;IP RTUModbus-RTU模式是指当控制器设为在Modbus网络上以RTU（远程终端模式）模式通信，在消息中的每个8Bit包含两个4Bit的十六进制字符。 1、信息帧发送至少要以3.5个字符时间的停顿间隔开始。在最后一个字符传输字符之后，一个至少3.5个字符时间的停顿标定了信息帧的结束。一个新的信息帧可在此停顿之后开始。如果一个新消息在小于3.5个字符时间内接着前个消息开始，接受的设备将认为它是前一信息帧的延续，这将导致CRC码的值出错。 2、整个信息帧必须作为一连续的流传输。如果在帧完成之前有超过1.5字符时间的停顿时间，接受设备将刷新不完整的信息帧并认为存在丢包现象。 功能码 01 读线圈状态 位操作 读单个或多个 02 读离散输入状态 位操作 读单个或多个 03 读保持寄存器 字操作 读单个或多个 04 读输入寄存器 字操作 读单个或多个 05 写单个线圈 位操作 单个 06 写单个保持寄存器 字操作 单个 15 写多个线圈 位操作 多个 16 写多个保持寄存器 字操作 多个 example code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131//GPIO9 is RXD1//GPIO10 is TXD1//帧结构 = 地址 + 功能码+ 数据 + 校验 = slaveID + 0X03 + 0X0#include &quot;DHT.h&quot;#include &lt;HardwareSerial.h&gt;#define DHTPIN 4 #define DHTTYPE DHT11DHT dht(DHTPIN, DHTTYPE);HardwareSerial SerialPort(1); // use UART1#define bufferSize 255 //一帧数据的最大字节数量 报文最大数量#define baudrate 9600 //定义通讯波特率#define slaveID 0x07 //定义modbus RTU从站站号#define modbusDataSize 100 //定义modbus数据库空间大小#define N 5void setup() &#123; Serial.begin(115200); Serial1.begin(9600, SERIAL_8N1, 35, 33); pinMode(32,OUTPUT); digitalWrite(32, LOW); dht.begin();&#125;void loop() &#123; //延时 unsigned int characterTime; //数据缓冲区定义 unsigned char frame[bufferSize]; //接收到的数据原始CRC unsigned int receivedCrc; //接收到的数据长度 unsigned char address=0; unsigned char temp_h;//温度整数部分 unsigned char temp_l;//温度小数部分 //读取DHT11温度 float h = dht.readHumidity(); // Read temperature as Celsius (the default) float t = dht.readTemperature(); // Read temperature as Fahrenheit (isFahrenheit = true) float f = dht.readTemperature(true); // Check if any reads failed and exit early (to try again). if (isnan(h) || isnan(t) || isnan(f)) &#123; Serial.println(F(&quot;Failed to read from DHT sensor!&quot;)); return; &#125; temp_h=(unsigned char ) t; temp_l=0x00; delay(100); //延时1.5个字符宽度 characterTime = 15000000/baudrate; //如果串口缓冲区数据量大于0进入条件 while(Serial1.available()&gt;0) &#123; //接收的数据量应小于一帧数据的最大字节数量 if(address&lt;bufferSize) &#123; frame[address]=Serial1.read(); Serial.write(frame[address]); address++; &#125; else &#123; //清空缓冲区 Serial1.read(); &#125; //延迟 delayMicroseconds(characterTime); //数据读取完成 if(Serial1.available()==0) &#123; //校验CRC unsigned short internalCrc = ModRTU_CRC((char*)frame, address-2); internalCrc &gt;&gt; 1; unsigned char high = internalCrc&amp;0xFF; unsigned char low = internalCrc&gt;&gt;8; Serial.write(&amp;frame[0], N+2); //校验通过 if(low==frame[address - 1]&amp;&amp;high==frame[address - 2]) &#123; unsigned char slaveCode = frame[0]; //设备号匹配，兼容广播模式 if(slaveCode==slaveID||slaveCode==0) &#123; //检查功能码 unsigned char funcCode = frame[1]; if(funcCode==3) &#123; //组装返回的数据 frame[2] = 0x02; frame[3] = temp_h; frame[4] = temp_l; //frame[5] = 0x00; //frame[6] = val; &#125; &#125; &#125; internalCrc = ModRTU_CRC((char*)frame, N); internalCrc &gt;&gt; 1; frame[N] = internalCrc&amp;0xFF; frame[N+1] = internalCrc&gt;&gt;8; digitalWrite(32, HIGH); Serial1.write(&amp;frame[0], N+2); Serial.write(&amp;frame[0], N+2); delay(10); digitalWrite(32, LOW); &#125; &#125;&#125;unsigned int ModRTU_CRC(char * buf, int len)&#123; unsigned int crc = 0xFFFF; for (int pos = 0; pos &lt; len; pos++) &#123; crc ^= (unsigned int)buf[pos]; for (int i = 8; i != 0; i--) &#123; if ((crc &amp; 0x0001) != 0) &#123; crc &gt;&gt;= 1; crc ^= 0xA001; &#125; else crc &gt;&gt;= 1; &#125; &#125; return crc; &#125;","categories":[],"tags":[{"name":"-通信","slug":"通信","permalink":"https://zjbcxiaotiancai.github.io/xiaowo.github.io/tags/%E9%80%9A%E4%BF%A1/"}]},{"title":"HEXO","slug":"HEXO","date":"2023-04-19T03:30:39.000Z","updated":"2023-04-23T12:20:29.784Z","comments":true,"path":"2023/04/19/HEXO/","link":"","permalink":"https://zjbcxiaotiancai.github.io/xiaowo.github.io/2023/04/19/HEXO/","excerpt":"","text":"Welcome to my first Hexo! If you get any problems when using Hexo, you can ask me on GitHub. HOW TO How to start your own HEXO blog安装Node.js此次所有内容都在nodejs的环境下搭建nodejs检测是否安装成功 1$ node -v 安装gitgit 安装hexo1$ npm install -g hexo-cli 初始化hexo文件夹1234567$ mkdir blog$ hexo init blog$ cd blog$ npm install$ hexo clean$ hexo g $ hexo s 此时进入4000端口就能访问到默认界面连接到github创建以 github名.github.io 形式的库并通过 12345$ npm install hexo-deployer-git --save #安装依赖$ git config --global user.name &quot;GitHub 用户名&quot;$ git config --global user.email &quot;GitHub 邮箱&quot;$ ssh-keygen -t rsa -C &quot;GitHub 邮箱&quot; #将得到的ssh加入到github主页$ ssh -T git@github.com #显示 “Hi xxx! You&#x27;ve successfully……” 即连接成功","categories":[],"tags":[{"name":"-web","slug":"web","permalink":"https://zjbcxiaotiancai.github.io/xiaowo.github.io/tags/web/"}]}],"categories":[],"tags":[{"name":"-Docker","slug":"Docker","permalink":"https://zjbcxiaotiancai.github.io/xiaowo.github.io/tags/Docker/"},{"name":"-go","slug":"go","permalink":"https://zjbcxiaotiancai.github.io/xiaowo.github.io/tags/go/"},{"name":"-通信","slug":"通信","permalink":"https://zjbcxiaotiancai.github.io/xiaowo.github.io/tags/%E9%80%9A%E4%BF%A1/"},{"name":"-web","slug":"web","permalink":"https://zjbcxiaotiancai.github.io/xiaowo.github.io/tags/web/"}]}