{"meta":{"title":"小蜗的博客","subtitle":"my blog","description":"this is my blog","author":"Elijah","url":"https://zjbcxiaotiancai.github.io/xiaowo.github.io","root":"/"},"pages":[{"title":"categories","date":"2023-04-21T03:05:18.000Z","updated":"2023-04-21T03:05:18.068Z","comments":true,"path":"categories/index.html","permalink":"https://zjbcxiaotiancai.github.io/xiaowo.github.io/categories/index.html","excerpt":"","text":""},{"title":"archives","date":"2023-04-21T03:09:30.000Z","updated":"2023-04-21T03:09:30.600Z","comments":true,"path":"archives/index.html","permalink":"https://zjbcxiaotiancai.github.io/xiaowo.github.io/archives/index.html","excerpt":"","text":""},{"title":"about","date":"2023-04-21T03:04:24.000Z","updated":"2023-04-21T03:04:24.257Z","comments":true,"path":"about/index.html","permalink":"https://zjbcxiaotiancai.github.io/xiaowo.github.io/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-04-21T03:04:58.000Z","updated":"2023-04-21T03:04:58.100Z","comments":true,"path":"tags/index.html","permalink":"https://zjbcxiaotiancai.github.io/xiaowo.github.io/tags/index.html","excerpt":"","text":""},{"title":"friends","date":"2023-04-21T03:04:49.000Z","updated":"2023-04-21T03:04:49.694Z","comments":true,"path":"friends/index.html","permalink":"https://zjbcxiaotiancai.github.io/xiaowo.github.io/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"基于GO语言-tcp扫描","slug":"基于GO语言-tcp扫描","date":"2023-05-14T01:33:36.000Z","updated":"2023-05-14T01:49:44.221Z","comments":true,"path":"2023/05/14/基于GO语言-tcp扫描/","link":"","permalink":"https://zjbcxiaotiancai.github.io/xiaowo.github.io/2023/05/14/%E5%9F%BA%E4%BA%8EGO%E8%AF%AD%E8%A8%80-tcp%E6%89%AB%E6%8F%8F/","excerpt":"","text":"tcp TCP的握手有三个过程，首先客户端发送一个syn的包，表示建立回话的开始，如果客户端收到超时，说明端口可能在防火墙后面。如果服务器应答了syn-ack包，意味着端口被打开了，否则会返回rst包，最后客户端需要另外发送一个ack包，此时连接已经建立。 项目说明 使用标准库中的net.Dial函数实现单个端口的测试 接下来利用flag包配置每个字符串或数字，以此方便修改数据 利用for循环逐一扫描 此时程序运行得极慢 建立协程，加锁 源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546package mainimport ( &quot;flag&quot; &quot;fmt&quot; &quot;net&quot; &quot;sync&quot; &quot;time&quot;)func isOpen(host string, port int, timeout time.Duration) bool &#123; time.Sleep(time.Millisecond * 1) conn, err := net.DialTimeout(&quot;tcp&quot;, fmt.Sprintf(&quot;%s:%d&quot;, host, port), timeout) if err == nil &#123; _ = conn.Close() return true &#125; return false&#125;func main() &#123; hostname := flag.String(&quot;hostname&quot;, &quot;baidu.com&quot;, &quot;hostname to test&quot;) startPort := flag.Int(&quot;startPort&quot;, 80, &quot;the port on which the scanning starts&quot;) endPort := flag.Int(&quot;end-port&quot;, 100, &quot;the port from which the scanning ends&quot;) timeout := flag.Duration(&quot;timeout&quot;, time.Millisecond*200, &quot;timeout&quot;) flag.Parse() ports := []int&#123;&#125; wg := &amp;sync.WaitGroup&#123;&#125; mutex := &amp;sync.Mutex&#123;&#125; for port := *startPort; port &lt;= *endPort; port++ &#123; wg.Add(1) go func(p int) &#123; opened := isOpen(*hostname, p, *timeout) if opened &#123; mutex.Lock() ports = append(ports, p) mutex.Unlock() &#125; wg.Done() &#125;(port) &#125; wg.Wait() fmt.Printf(&quot;opened.ports:%v\\n&quot;, ports)&#125; 本文转自：https://mp.weixin.qq.com/s/OhS_RQZojJbkenOSS_tEng","categories":[],"tags":[{"name":"-go","slug":"go","permalink":"https://zjbcxiaotiancai.github.io/xiaowo.github.io/tags/go/"}]},{"title":"Modbus","slug":"modbus","date":"2023-04-23T12:00:55.000Z","updated":"2023-04-23T12:20:19.597Z","comments":true,"path":"2023/04/23/modbus/","link":"","permalink":"https://zjbcxiaotiancai.github.io/xiaowo.github.io/2023/04/23/modbus/","excerpt":"","text":"modbus ModbusASCLL ModbusRTU - 二进制编码 - CRC错误校验 ModbusTCP&#x2F;IP RTUModbus-RTU模式是指当控制器设为在Modbus网络上以RTU（远程终端模式）模式通信，在消息中的每个8Bit包含两个4Bit的十六进制字符。 1、信息帧发送至少要以3.5个字符时间的停顿间隔开始。在最后一个字符传输字符之后，一个至少3.5个字符时间的停顿标定了信息帧的结束。一个新的信息帧可在此停顿之后开始。如果一个新消息在小于3.5个字符时间内接着前个消息开始，接受的设备将认为它是前一信息帧的延续，这将导致CRC码的值出错。 2、整个信息帧必须作为一连续的流传输。如果在帧完成之前有超过1.5字符时间的停顿时间，接受设备将刷新不完整的信息帧并认为存在丢包现象。 功能码 01 读线圈状态 位操作 读单个或多个 02 读离散输入状态 位操作 读单个或多个 03 读保持寄存器 字操作 读单个或多个 04 读输入寄存器 字操作 读单个或多个 05 写单个线圈 位操作 单个 06 写单个保持寄存器 字操作 单个 15 写多个线圈 位操作 多个 16 写多个保持寄存器 字操作 多个 example code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131//GPIO9 is RXD1//GPIO10 is TXD1//帧结构 = 地址 + 功能码+ 数据 + 校验 = slaveID + 0X03 + 0X0#include &quot;DHT.h&quot;#include &lt;HardwareSerial.h&gt;#define DHTPIN 4 #define DHTTYPE DHT11DHT dht(DHTPIN, DHTTYPE);HardwareSerial SerialPort(1); // use UART1#define bufferSize 255 //一帧数据的最大字节数量 报文最大数量#define baudrate 9600 //定义通讯波特率#define slaveID 0x07 //定义modbus RTU从站站号#define modbusDataSize 100 //定义modbus数据库空间大小#define N 5void setup() &#123; Serial.begin(115200); Serial1.begin(9600, SERIAL_8N1, 35, 33); pinMode(32,OUTPUT); digitalWrite(32, LOW); dht.begin();&#125;void loop() &#123; //延时 unsigned int characterTime; //数据缓冲区定义 unsigned char frame[bufferSize]; //接收到的数据原始CRC unsigned int receivedCrc; //接收到的数据长度 unsigned char address=0; unsigned char temp_h;//温度整数部分 unsigned char temp_l;//温度小数部分 //读取DHT11温度 float h = dht.readHumidity(); // Read temperature as Celsius (the default) float t = dht.readTemperature(); // Read temperature as Fahrenheit (isFahrenheit = true) float f = dht.readTemperature(true); // Check if any reads failed and exit early (to try again). if (isnan(h) || isnan(t) || isnan(f)) &#123; Serial.println(F(&quot;Failed to read from DHT sensor!&quot;)); return; &#125; temp_h=(unsigned char ) t; temp_l=0x00; delay(100); //延时1.5个字符宽度 characterTime = 15000000/baudrate; //如果串口缓冲区数据量大于0进入条件 while(Serial1.available()&gt;0) &#123; //接收的数据量应小于一帧数据的最大字节数量 if(address&lt;bufferSize) &#123; frame[address]=Serial1.read(); Serial.write(frame[address]); address++; &#125; else &#123; //清空缓冲区 Serial1.read(); &#125; //延迟 delayMicroseconds(characterTime); //数据读取完成 if(Serial1.available()==0) &#123; //校验CRC unsigned short internalCrc = ModRTU_CRC((char*)frame, address-2); internalCrc &gt;&gt; 1; unsigned char high = internalCrc&amp;0xFF; unsigned char low = internalCrc&gt;&gt;8; Serial.write(&amp;frame[0], N+2); //校验通过 if(low==frame[address - 1]&amp;&amp;high==frame[address - 2]) &#123; unsigned char slaveCode = frame[0]; //设备号匹配，兼容广播模式 if(slaveCode==slaveID||slaveCode==0) &#123; //检查功能码 unsigned char funcCode = frame[1]; if(funcCode==3) &#123; //组装返回的数据 frame[2] = 0x02; frame[3] = temp_h; frame[4] = temp_l; //frame[5] = 0x00; //frame[6] = val; &#125; &#125; &#125; internalCrc = ModRTU_CRC((char*)frame, N); internalCrc &gt;&gt; 1; frame[N] = internalCrc&amp;0xFF; frame[N+1] = internalCrc&gt;&gt;8; digitalWrite(32, HIGH); Serial1.write(&amp;frame[0], N+2); Serial.write(&amp;frame[0], N+2); delay(10); digitalWrite(32, LOW); &#125; &#125;&#125;unsigned int ModRTU_CRC(char * buf, int len)&#123; unsigned int crc = 0xFFFF; for (int pos = 0; pos &lt; len; pos++) &#123; crc ^= (unsigned int)buf[pos]; for (int i = 8; i != 0; i--) &#123; if ((crc &amp; 0x0001) != 0) &#123; crc &gt;&gt;= 1; crc ^= 0xA001; &#125; else crc &gt;&gt;= 1; &#125; &#125; return crc; &#125;","categories":[],"tags":[{"name":"-通信","slug":"通信","permalink":"https://zjbcxiaotiancai.github.io/xiaowo.github.io/tags/%E9%80%9A%E4%BF%A1/"}]},{"title":"HEXO","slug":"HEXO","date":"2023-04-19T03:30:39.000Z","updated":"2023-04-23T12:20:29.784Z","comments":true,"path":"2023/04/19/HEXO/","link":"","permalink":"https://zjbcxiaotiancai.github.io/xiaowo.github.io/2023/04/19/HEXO/","excerpt":"","text":"Welcome to my first Hexo! If you get any problems when using Hexo, you can ask me on GitHub. HOW TO How to start your own HEXO blog安装Node.js此次所有内容都在nodejs的环境下搭建nodejs检测是否安装成功 1$ node -v 安装gitgit 安装hexo1$ npm install -g hexo-cli 初始化hexo文件夹1234567$ mkdir blog$ hexo init blog$ cd blog$ npm install$ hexo clean$ hexo g $ hexo s 此时进入4000端口就能访问到默认界面连接到github创建以 github名.github.io 形式的库并通过 12345$ npm install hexo-deployer-git --save #安装依赖$ git config --global user.name &quot;GitHub 用户名&quot;$ git config --global user.email &quot;GitHub 邮箱&quot;$ ssh-keygen -t rsa -C &quot;GitHub 邮箱&quot; #将得到的ssh加入到github主页$ ssh -T git@github.com #显示 “Hi xxx! You&#x27;ve successfully……” 即连接成功","categories":[],"tags":[{"name":"-web","slug":"web","permalink":"https://zjbcxiaotiancai.github.io/xiaowo.github.io/tags/web/"}]}],"categories":[],"tags":[{"name":"-go","slug":"go","permalink":"https://zjbcxiaotiancai.github.io/xiaowo.github.io/tags/go/"},{"name":"-通信","slug":"通信","permalink":"https://zjbcxiaotiancai.github.io/xiaowo.github.io/tags/%E9%80%9A%E4%BF%A1/"},{"name":"-web","slug":"web","permalink":"https://zjbcxiaotiancai.github.io/xiaowo.github.io/tags/web/"}]}